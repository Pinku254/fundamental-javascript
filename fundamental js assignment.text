1. Explain the role of operators in JavaScript. Why are they essential in programming?
sol:
Performing Operations: Operators allow programmers to perform various operations such as arithmetic (addition, subtraction, etc.), comparison (equality, inequality, etc.), logical (AND, OR, NOT), assignment, bitwise, and more. These operations are fundamental for manipulating data and controlling the flow of a program.

Expressiveness: Operators make code more expressive and concise. Instead of writing lengthy functions or methods to perform basic operations, operators provide a shorthand way to achieve the same results. This enhances readability and maintainability of the code.

Efficiency: Using operators often leads to more efficient code execution compared to alternative methods. Many operators are implemented as low-level operations in the underlying language, which can be executed more efficiently by the interpreter or compiler. 

Flexibility: Operators allow for the manipulation of different types of data, including numbers, strings, booleans, and objects. They provide flexibility in how data is processed and manipulated within a program.

Control Flow: Operators are essential for controlling the flow of a program through conditional statements (e.g., if-else statements, ternary operators) and loops (e.g., for loops, while loops). They enable decision-making and iteration, which are fundamental aspects of programming logic.

 2. Describe the categorization of operators in Javascript based on their functionality. Provide examples for each category.
Sol:
Arithmetic Operators: These operators are used to perform arithmetic operations on numeric values.
Addition (+): 
Subtraction (-): 
Multiplication ():
Division (/): 
Modulus (%): 
Assignment Operators: These operators are used to assign values to variables.
Assignment (=): let x = 10;
Addition assignment (+=): x += 5; 
Subtraction assignment (-=): x -= 3; 
Multiplication assignment (=): x *= 2;
Division assignment (/=): x /= 4; 

Comparison Operators: These operators are used to compare values and return a Boolean result.
Equal to (==): 5 == 5; 
Not equal to (!=): 5 != 3; 
Strict equal to (===): 5 === '5'; 
Strict not equal to (!==): 5 !== '5'; 
Greater than (>): 10 > 5; 
Less than (<): 3 < 8; 
Greater than or equal to (>=): 7 >= 7;
Less than or equal to (<=): 4 <= 4; 

3. Differentiate between unary, binary, and ternary operators in Javascript. Give examples of each.
Sol:
Unary Operators: Unary operators work with only one operand.Examples:
Unary Plus (+): Converts its operand to a number, or evaluates the expression to the right of it.let num = +"5"; 
Unary Minus (-): Negates its operand.let negNum = -10; 
Increment (++) 
Decrement (--):
a++; 
let b = 10;
b--; 
Binary Operators: Binary operators work with two operands.Examples:
Addition (+): 
Subtraction (-): Subtracts the second operand from the first.
Multiplication (*)

4.Discuss the precedence and associativity of operators in Javascript. Why is understanding these concepts.
Sol:
In JavaScript, operators have precedence and associativity rules that determine the order in which they are evaluated when multiple operators are present in an expression.

Precedence: Precedence defines the priority of operators in an expression. Operators with higher precedence are evaluated before those with lower precedence. For example, multiplication (*) has a higher precedence than addition (+), so it will be evaluated first.

Associativity: Associativity defines the order in which operators of the same precedence are evaluated. It can be left-to-right or right-to-left. For example, the addition operator (+) is left-associative, meaning that expressions are evaluated from left to right, while the assignment operator (=) is right-associative, meaning that expressions are evaluated from right to left.

Correct Evaluation: Understanding precedence and associativity ensures that expressions are evaluated correctly according to the intended logic. This helps prevent errors and unexpected behavior in the code.

Clarity and Readability: By following precedence and associativity rules, developers can write code that is easier to understand and maintain. It helps in avoiding ambiguity and makes the code more predictable for other developers.

Optimization: Knowledge of operator precedence can help optimize code by avoiding unnecessary parentheses and ensuring that expressions are evaluated efficiently.
Avoiding Bugs: Incorrect understanding or application of precedence and associativity can lead to bugs and errors in the code. Therefore, having a clear understanding of these concepts is crucial for writing robust and reliable JavaScript code.


5.Write a Javascript program that calculates the simple interest using the formula Simple interest=
(principal * rate * time)/ 100.
Sol:
function calculateSimpleInterest(principal, rate, time) {

    return (principal * rate * time) / 100;
}
let principal = 1000; 
let rate = 5; 
let time = 2; 


const simpleInterest = calculateSimpleInterest(principal, rate, time);

console.log("Principal:", principal);
console.log("Rate of Interest:", rate, "%");
console.log("Time Period:", time, "years");
console.log("Simple Interest:", simpleInterest);

6.Write a Javascript program to calculate the Body Mass Index (BMI) using the formula BMI= weight (kg)/
height *height.
Sol:
function calculateBMI(weight, height) {
    weight (kg) / height (m) ^ 2
    return weight / (height * height);
}

const weight = 70; 
const height = 1.75; 

const bmi = calculateBMI(weight, height);

console.log("Weight:", weight, "kg");
console.log("Height:", height, "m");
console.log("BMI:", bmi.toFixed(2)); 

7. Write a program in Javascript to calculate the area ofc a circle  given its radius value of  Use appropriate arithmetic operators.
function calculateCircleArea(radius) {
    // Area formula: π * radius^2
    return π* radius * radius;
}

const radius = 10;
const area = calculateCircleArea(radius);

console.log("Radius:", radius);
console.log("Area of the circle:", area.toFixed(2)); 